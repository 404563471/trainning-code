---
title: "r-plot"
author: "mason-YHY"
date: "6/18/2020"
output: html_document
---

相关性分析图--corrplot
=========================================================
```{r}
library(corrplot)
data("mtcars")
head(mtcars)
M <- cor(mtcars, method = "pearson")
M2 <- cor(mtcars, method = "spearman")
M3 <- cor(mtcars, method = "kendall")

## different cor method
corrplot(M)
corrplot(M2)
corrplot(M3)

## different order
corrplot(M, order = "AOE")
corrplot(M, order = "FPC")
corrplot(M, order = "hclust")
corrplot(M, order = "hclust", hclust.method = "ward.D2", addrect = 3, rect.col = "red")

##  different color series
col1 <- colorRampPalette(c("#7F0000", "red", "#FF7F00", "yellow", "white",
                           "cyan", "#007FFF", "blue","#00007F"))
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582",
                           "#FDDBC7", "#FFFFFF", "#D1E5F0", "#92C5DE",
                           "#4393C3", "#2166AC", "#053061"))
col3 <- colorRampPalette(c("red", "white", "blue"))
col4 <- colorRampPalette(c("#7F0000", "red", "#FF7F00", "yellow", "#7FFF7F",
                           "cyan", "#007FFF", "blue", "#00007F"))
wb <- c("white", "black")
## different color
corrplot(M, order = "hclust", hclust.method = "ward.D2", addrect = 3, rect.col = "red",
         col = col1(200))
corrplot(M, order = "hclust", hclust.method = "ward.D2", addrect = 3, rect.col = "red",
         col = col2(200))
corrplot(M, order = "hclust", hclust.method = "ward.D2", addrect = 3, rect.col = "red",
         col = col3(200))

## different grid
corrplot(M, method = "color", order = "AOE", addCoef.col = "grey")
corrplot(M, method = "square", order = "AOE")
corrplot(M, method = "ellipse", order = "AOE")
corrplot(M, method = "shade", order = "AOE")
corrplot(M, method = "pie", order = "AOE")

## col = wb
corrplot(M, col = wb, order = "AOE", outline = TRUE, cl.pos = "n")
## like Chinese wiqi, suit for either on screen or white-black print.
corrplot(M, col = wb, bg = "gold2",  order = "AOE", cl.pos = "n")

## mixed methods: It's more efficient if using function "corrplot.mixed"
## circle + ellipse
corrplot(M, order = "AOE", type = "upper", tl.pos = "d")
corrplot(M, add = TRUE, type = "lower", method = "ellipse", order = "AOE",
         diag = FALSE, tl.pos = "n", cl.pos = "n")
## circle + colorful number
corrplot(M, order = "AOE", type = "upper", tl.pos = "d")
corrplot(M, add = TRUE, type = "lower", method = "number", order = "AOE",
         diag = FALSE, tl.pos = "n", cl.pos = "n")

## visualize a  matrix in [-100, 100]
ran <- round(matrix(runif(225, -100,100), 15))
corrplot(ran, is.corr = FALSE)
corrplot(ran, is.corr = FALSE, cl.lim = c(-100, 150))

## text-labels and plot type
corrplot(M, order = "AOE", tl.srt = 30, type = "upper", diag = FALSE)

## specialized the insignificant value according to the significant level
res1 <- cor.mtest(mtcars, conf.level = 0.95)
corrplot(M, p.mat = res1$p, sig.level = 0.01)
corrplot(M, p.mat = res1$p, sig.level = 0.01, insig = "blank")
corrplot(M, p.mat = res1$p, sig.level = 0.01, insig = "p-value")

## plot confidence interval(0.95)
corrplot(M, p.mat = res1$p, low = res1$lowCI, upp = res1$uppCI,
         col = c("white", "black"), bg = "gold2", order = "AOE",
         plotCI = "circle", cl.pos = "n", pch.col = "red")
corrplot(M, p.mat = res1$p, low = res1$lowCI, upp = res1$uppCI,
         col = c("white","black"), bg = "gold2", order = "AOE", pch.col = "red",
         plotCI = "square", addg = NULL, cl.pos = "n")


```

聚类热图--pheatmap
===========================================================
```{r}
library(pheatmap)
# Create test matrix
test = matrix(rnorm(200), 20, 10)
test[1:10, seq(1, 10, 2)] = test[1:10, seq(1, 10, 2)] + 3
test[11:20, seq(2, 10, 2)] = test[11:20, seq(2, 10, 2)] + 2
test[15:20, seq(2, 10, 2)] = test[15:20, seq(2, 10, 2)] + 4
colnames(test) = paste("Test", 1:10, sep = "")
rownames(test) = paste("Gene", 1:20, sep = "")
test

# Draw heatmaps
pheatmap(test)
pheatmap(test, scale = "row", clustering_distance_rows = "correlation")
pheatmap(test, color = colorRampPalette(c("navy", "white", "firebrick3"))(50))
pheatmap(test, cluster_row = FALSE)
```

```{r}
# Show text within cells
pheatmap(test, display_numbers = TRUE)
pheatmap(test, display_numbers = TRUE, number_format = "%.1e")
pheatmap(test, display_numbers = matrix(ifelse(test > 5, "*", ""), nrow(test)))
pheatmap(test, cluster_row = FALSE, legend_breaks = -1:4, legend_labels = c("0",
"1e-4", "1e-3", "1e-2", "1e-1", "1"))

# Fix cell sizes and save to file with correct size
pheatmap(test, cellwidth = 15, cellheight = 12, main = "Example heatmap")
pheatmap(test, cellwidth = 15, cellheight = 12, fontsize = 8, filename = "test.pdf")
```

```{r}
# Generate annotations for rows and columns
annotation_col = data.frame(CellType = factor(rep(c("CT1", "CT2"), 5)), Time = 1:5)

rownames(annotation_col) = paste("Test", 1:10, sep = "")

annotation_row = data.frame(GeneClass = factor(rep(c("Path1", "Path2", "Path3"), c(10, 4, 6))))
rownames(annotation_row) = paste("Gene", 1:20, sep = "")

# Display row and color annotations
pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row)
```

```{r}
# Change angle of text in the columns
pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, angle_col = "45")

# Specify colors
ann_colors = list(
    Time = c("white", "firebrick"),
    CellType = c(CT1 = "#1B9E77", CT2 = "#D95F02"),
    GeneClass = c(Path1 = "#7570B3", Path2 = "#E7298A", Path3 = "#66A61E")
)

pheatmap(test, annotation_col = annotation_col, annotation_row = annotation_row, 
         annotation_colors = ann_colors)

# Gaps in heatmaps
pheatmap(test, annotation_col = annotation_col, cluster_rows = FALSE, gaps_row = c(10, 14), cutree_col = 2)

# Show custom strings as row/col names
labels_row = c("", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
"", "", "Il10", "Il15", "Il1b")
pheatmap(test, annotation_col = annotation_col, labels_row = labels_row)
```

ggbiplot
===========================================================
```{r}
#library(devtools)
#install_github("vqv/ggbiplot")
library(ggbiplot)
pca.data <- iris[, 1:4]
pca.group <- iris[, 5]

pca.out <- prcomp(pca.data, scale. = TRUE) 

summary(pca.out)
print(pca.out)
pca_data <- predict(pca.out)

ggbiplot(pca.out, groups = iris$Species, ellipse = T, var.axes = F)
ggbiplot(pca.out, groups = iris$Species, ellipse = T, var.axes = T)

pca_data <- as.data.frame(pca_data)
pca_data$group <- iris$Species
ggplot(data = pca_data, aes(x=PC1, y=PC2, color=group)) + geom_jitter()

ggbiplot(pca.out, groups = iris$Species, ellipse = T, var.axes = F)
```

KM plot
==============================================
```{r}
library("survival")
library("survminer")
data(lung)
lung <- na.omit(lung)

fit<- survfit(Surv(time, status) ~ 1, data = lung)
ggsurvplot(fit, data = lung)

fit<- survfit(Surv(time, status) ~ sex, data = lung)
ggsurvplot(fit, data = lung)
```

```{r}
fit<- coxph(Surv(time, status) ~ age, data = lung)
haz <- predict(fit)
lung$haz <- ifelse(haz <= median(haz), "low", "height")
fit <- survfit(Surv(time, status) ~ haz, data = lung)
ggsurvplot(fit, data = lung)

lung$ageGroup <- ifelse(lung$age <= median(lung$age), "low", "height")
fit <- survfit(Surv(time, status) ~ ageGroup, data = lung)
ggsurvplot(fit, data = lung)


fit <- coxph(Surv(time, status) ~ age + ph.ecog, data = lung)
haz <- predict(fit)
lung$haz <- ifelse(haz <= median(haz), "low", "height")
fit <- survfit(Surv(time, status) ~ haz, data = lung)
ggsurvplot(fit, data = lung)
```

ROC
===================================================
```{r}
library(pROC)
data(aSAH)
rocobj <- roc(aSAH$outcome, aSAH$s100b)
rocobj2 <- roc(aSAH$outcome, aSAH$wfns)
rocobj3 <- roc(aSAH$outcome, aSAH$ndka)

g <- ggroc(rocobj, legacy.axes = TRUE)
g

g + theme_minimal() + 
  ggtitle("My ROC curve") + 
  geom_segment(aes(x = 0, xend = 1, y = 0, yend = 1), color="grey", linetype="dashed")

g2 <- ggroc(list(s100b=rocobj, wfns=rocobj2, ndka=rocobj3), legacy.axes = TRUE)
g2 + theme_minimal()
```

transition plot
===========================================================
```{r, message=FALSE}
library(Gmisc)
before <- sample(1:3, replace = TRUE, size = 500, prob = c(0.1, 0.4, 0.5))
after <- sample(1:3, replace = TRUE, size = 500, prob = c(0.3, 0.5, 0.2))
before <- factor(before, labels = c("None", "Moderate", "Major"))
after <- factor(after, labels = c("None", "Moderate", "Major"))
# Create the transition matrix
transition_matrix <- table(before, after)
# Create a table with the transitions
htmlTable(transition_matrix, title = "Transitions", ctable = TRUE)

transitionPlot(transition_matrix)
```

```{r}
transitionPlot(transition_matrix, overlap_add_width = 1.3, type_of_arrow = "gradient")
```
```{r}
transitionPlot(transition_matrix, txt_start_clr = "black", txt_end_clr = "black",
               fill_start_box = c("#E69F00", "#56B4E9", "#009E73"), 
               fill_end_box = c("#E69F00", "#56B4E9", "#009E73"),
               overlap_add_width = 1.3, type_of_arrow = "gradient")
```
```{r}
transitionPlot(transition_matrix,  box_prop = cbind(c(0.3, 0.7, 0.5), c(0.5, 0.5, 0.4)),
               txt_start_clr = c("black", "white"), txt_end_clr = c("black", "white"),
               fill_start_box = c("#999999", "#56B4E9"), 
               fill_end_box = c("#999999", "#56B4E9"), 
               overlap_add_width = 1.3, type_of_arrow = "gradient")
```

